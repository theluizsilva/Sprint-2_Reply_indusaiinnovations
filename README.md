# FIAP - Faculdade de Inform√°tica e Administra√ß√£o Paulista 

<p align="center">
<a href= "https://www.fiap.com.br/"><img src="assets/logo-fiap.png" alt="FIAP - Faculdade de Inform√°tica e Admnistra√ß√£o Paulista" border="0" width=40% height=40%></a>
</p>

<br>

# üè≠ IndusAI Innovations ‚Äì Plataforma de Monitoramento e Preven√ß√£o de Falhas em Linhas de Produ√ß√£o Industrial

---

## üë®‚Äçüéì Integrantes e Responsabilidades:

| Nome Completo                     | RM        | Responsabilidade Principal                                                                 |
|----------------------------------|-----------|----------------------------------------------------------------------------------------------|
| Daniele Antonieta Garisto Dias  | RM565106  | Coleta de dados com ESP32, comunica√ß√£o via MQTT e testes de dados                          |
| Leandro Augusto Jardim da Cunha | RM561395  | Desenvolvimento do dashboard com Streamlit, relat√≥rios gerenciais e organiza√ß√£o do reposit√≥rio |
| Luiz Eduardo da Silva            | RM561701  | Arquitetura da solu√ß√£o, integra√ß√£o AWS e apoio √† documenta√ß√£o t√©cnica                      |
| Jo√£o Victor Viana de Sousa       | RM565136  | Modelagem de Machine Learning, treinamento dos algoritmos e apoio ao versionamento         |

---

## üë©‚Äçüè´ Professores:
### Tutor(a) 
- <a>Leonardo Ruiz Orabona</a>
### Coordenador(a)
- <a>Andre Godoi Chiovato</a>

---

## üè¢ Sobre a Hermes Reply

A Hermes Reply √© uma empresa do grupo Reply que atua na linha de frente da transforma√ß√£o digital no setor industrial. Especializada em solu√ß√µes inteligentes, ela combina tecnologias como Intelig√™ncia Artificial (IA), Internet das Coisas (IoT), G√™meos Digitais e Machine Learning para desenvolver sistemas capazes de monitorar, controlar e otimizar processos produtivos de forma eficiente.

Seu principal objetivo √© ajudar as ind√∫strias a aumentarem a produtividade, reduzirem custos e evitarem falhas inesperadas, conectando sensores e dispositivos f√≠sicos a plataformas digitais na nuvem. Com isso, permite que os gestores tenham acesso a dados em tempo real para tomar decis√µes mais precisas e preventivas, promovendo uma manuten√ß√£o mais estrat√©gica e preditiva dos ativos.

Entre os principais recursos oferecidos pela empresa est√£o o controle inteligente da produ√ß√£o em tempo real, dashboards intuitivos para operadores e gestores, alertas autom√°ticos baseados no comportamento dos equipamentos, relat√≥rios gerados por IA, integra√ß√£o entre o ch√£o de f√°brica e sistemas digitais, al√©m de an√°lises preditivas com base em dados hist√≥ricos para apoiar a tomada de decis√£o.

---

## üìå Sum√°rio Executivo

IndusAI Innovations √© uma solu√ß√£o completa de monitoramento preditivo voltada √† preven√ß√£o de falhas operacionais em linhas de produ√ß√£o industrial. Combinando sensores IoT, modelos de machine learning e servi√ßos de nuvem, a plataforma permite prever anomalias em equipamentos, reduzir custos com manuten√ß√£o corretiva e aumentar a produtividade por meio de dashboards em tempo real e alertas inteligentes.

---

## üßæ Business Case

**Cliente fict√≠cio:** Ind√∫stria GlobalTech S.A. (setor de manufatura automotiva)

* **Problema identificado:** M√©dia de 11 horas de paralisa√ß√£o mensal por falha de motor ou superaquecimento em linhas cr√≠ticas.
* **Perda estimada:** R$ 92.000,00/m√™s em produtividade e R$ 25.000,00/m√™s em manuten√ß√£o emergencial.
* **Objetivo com IndusAI Innovations:** Reduzir falhas inesperadas em 70%, reverter o modelo de manuten√ß√£o corretiva para preditiva e permitir planejamento com base em dados.

---

## üéØ Objetivo da Solu√ß√£o

* Monitorar sensores de vibra√ß√£o, temperatura e ru√≠do em tempo real.
* Transmitir dados continuamente para a nuvem via protocolo MQTT.
* Processar os dados com modelos de machine learning para detectar padr√µes de falha iminente.
* Gerar visualiza√ß√µes acess√≠veis e alertas inteligentes para operadores e gestores.

---

## üß† L√≥gica e Arquitetura da Solu√ß√£o

1.  **Dispositivos IoT e Coleta de Dados**
    * Placas ESP32 conectadas a sensores anal√≥gicos (ex: aceler√¥metros MEMS para vibra√ß√£o, termistores NTC para temperatura, microfones com amplificador para ru√≠do).
    * Coleta cont√≠nua de dados f√≠sicos.
        * **Vibra√ß√£o:** Amostragem em alta frequ√™ncia (ex: 1-5 kHz) para capturar espectros relevantes. Features a serem extra√≠das incluem RMS, valor de pico, fator de crista, an√°lise no dom√≠nio da frequ√™ncia (FFT para identificar frequ√™ncias an√¥malas caracter√≠sticas de desalinhamento, desgaste de rolamentos, etc.).
        * **Temperatura:** Amostragem em frequ√™ncia moderada (ex: 1 Hz). Features incluem valor absoluto, taxa de varia√ß√£o da temperatura.
        * **Ru√≠do:** Amostragem em frequ√™ncia aud√≠vel (ex: 10-20 kHz). Features incluem n√≠vel de press√£o sonora (SPL), an√°lise espectral para identificar padr√µes sonoros anormais.
    * A frequ√™ncia de amostragem ser√° ajustada conforme o tipo de equipamento e as falhas t√≠picas esperadas, buscando um equil√≠brio entre detalhe da informa√ß√£o e volume de dados.

2.  **Transmiss√£o, Pr√©-processamento e Entrada de Dados**
    * Dados enviados via MQTT para o AWS IoT Core, utilizando JSON como formato de payload.
    * **AWS Lambda Functions para Pr√©-processamento:**
        * **Valida√ß√£o e Limpeza:** Verifica√ß√£o da integridade dos dados recebidos, tratamento de valores ausentes ou outliers b√°sicos.
        * **Normaliza√ß√£o/Padroniza√ß√£o:** Aplica√ß√£o de t√©cnicas como Min-Max scaling ou Z-score para colocar os dados em uma escala comum, essencial para algoritmos de ML.
        * **Segmenta√ß√£o (Janelamento):** Agrupamento dos dados sequenciais em janelas de tempo fixas (ex: dados de vibra√ß√£o dos √∫ltimos 5 segundos) para criar inst√¢ncias para os modelos de ML.
        * **Extra√ß√£o de Features (se n√£o totalmente no Edge):** C√°lculo de features estat√≠sticas ou no dom√≠nio da frequ√™ncia mais complexas que n√£o foram poss√≠veis de calcular no ESP32 devido a limita√ß√µes de processamento.

3.  **Armazenamento e Processamento Principal**
    * Dados pr√©-processados e features persistidos no AWS RDS (MySQL) para hist√≥rico e re-treinamento. Dados brutos podem ser arquivados no AWS S3 para an√°lises futuras mais profundas.
    * Scripts em inst√¢ncias AWS EC2 (ex: `t3.medium` ou superior, dependendo da carga) executam o processamento dos dados com `Scikit-learn` e `TensorFlow/Keras`.
        * **Processamento:** Pode ser configurado em modo batch (ex: a cada X minutos, processando os dados acumulados) ou em micro-batches para uma abordagem de streaming mais pr√≥xima do tempo real, utilizando bibliotecas como Apache Spark (via AWS EMR) ou Kinesis Data Analytics para aplica√ß√µes mais exigentes em futuras fases.
        * **Versionamento de Modelos:** Artefatos dos modelos treinados (arquivos, metadados de performance) ser√£o versionados e armazenados no AWS S3, utilizando tags para identificar vers√µes de produ√ß√£o, experimentais, etc. Ferramentas como MLflow podem ser consideradas para gerenciamento do ciclo de vida dos modelos.

4.  **Modelo de IA (Machine Learning)**
    * **Treinamento:** Supervisionado, utilizando dados hist√≥ricos rotulados (condi√ß√µes normais, padr√µes de pr√©-falha, falhas confirmadas) e dados sint√©ticos para aumentar a robustez em cen√°rios de falhas raras.
        * **Rotulagem de Dados Hist√≥ricos:** Requer an√°lise de logs de manuten√ß√£o, feedback de operadores e especialistas para correlacionar os dados dos sensores com eventos de falha ou pr√©-falha. Um evento de "pr√©-falha" pode ser definido por um conjunto de leituras an√¥malas que precedem uma falha conhecida em um intervalo de X horas/dias.
    * **Algoritmos e Justificativa:**
        * **Random Forest:** Robusto para dados tabulares, bom desempenho geral, lida bem com features n√£o lineares e fornece import√¢ncia das features, auxiliando na interpretabilidade. Adequado para uma primeira camada de classifica√ß√£o de estado do equipamento.
        * **LSTM (Long Short-Term Memory Networks):** Ideal para dados de s√©ries temporais (vibra√ß√£o, temperatura ao longo do tempo), capturando depend√™ncias temporais e padr√µes sequenciais que podem indicar degrada√ß√£o progressiva.
        * **Redes Neurais Densas (DNN):** Para modelagem de rela√ß√µes complexas entre as features, podendo alcan√ßar alta acur√°cia ap√≥s o devido ajuste de hiperpar√¢metros e com volume de dados suficiente.
    * **Avalia√ß√£o e Valida√ß√£o:**
        * M√©tricas: F1-score (bom para classes desbalanceadas como "falha"), AUC-ROC, Precision, Recall e Matriz de Confus√£o para entender os tipos de erro.
        * **Estrat√©gia de Valida√ß√£o:** Valida√ß√£o cruzada (ex: K-Fold Cross-Validation, TimeSeriesSplit para dados temporais) durante o desenvolvimento. Divis√£o em conjuntos de treino (60-70%), valida√ß√£o (15-20%) e teste (15-20%), garantindo que o conjunto de teste seja temporalmente posterior aos dados de treino e valida√ß√£o para simular um cen√°rio real de previs√£o.

5.  **Visualiza√ß√£o e Alertas Inteligentes**
    * **Dashboard Interativo (`Streamlit`):**
        * **M√©tricas Chave:** Health score do equipamento (ex: 0-100%), tempo estimado para pr√≥xima manuten√ß√£o (ETTM), probabilidade de falha nas pr√≥ximas X horas, principais features indicando anomalia.
        * **Visualiza√ß√µes:** Gr√°ficos de s√©rie temporal dos dados dos sensores, espectrogramas (para vibra√ß√£o/ru√≠do), comparativos entre equipamentos, hist√≥rico de alertas e status preditivo.
        * **N√≠veis de Acesso:** Diferentes visualiza√ß√µes para operadores (foco no status atual e alertas imediatos) e gestores (foco em tend√™ncias, KPIs de disponibilidade, custos evitados).
    * **Alertas Inteligentes e Notifica√ß√µes:**
        * Notifica√ß√µes via Telegram Bot, e-mails (SMTP) ou alertas visuais/sonoros no painel de controle da linha.
        * **N√≠veis de Criticidade:**
            * **Aten√ß√£o (Amarelo):** Desvios leves detectados, sugerir inspe√ß√£o agendada.
            * **Alerta (Laranja):** Padr√µes de pr√©-falha identificados, manuten√ß√£o recomendada em breve.
            * **Cr√≠tico (Vermelho):** Alta probabilidade de falha iminente, sugerir parada programada ou interven√ß√£o imediata.
        * **Configura√ß√£o:** Limiares de alerta ajust√°veis e l√≥gica para suprimir falsos positivos (ex: requerer m√∫ltiplas leituras an√¥malas consecutivas ou combina√ß√£o de sensores).
    * Logs hist√≥ricos de alertas e previs√µes armazenados para an√°lise retroativa e auditoria.

---

## üîê Seguran√ßa e Confiabilidade

* **Autentica√ß√£o:** MQTT com TLS/SSL para criptografia em tr√¢nsito + autentica√ß√£o de dispositivos (certificados X.509) no AWS IoT Core.
* **Controle de acesso:** AWS IAM (Identity and Access Management) com pol√≠ticas de privil√©gio m√≠nimo para todos os servi√ßos AWS.
* **Criptografia:** Dados criptografados em tr√¢nsito (TLS/SSL) e em repouso (ex: AWS KMS para RDS e S3).
* **Logs e rastreabilidade:** AWS CloudWatch Logs para logs de aplica√ß√µes e servi√ßos, AWS CloudTrail para auditoria de chamadas de API. Rastreabilidade de alertas e a√ß√µes tomadas.

---

## üìà Escalabilidade e Evolu√ß√£o

* **Escalabilidade horizontal:** Uso de Auto Scaling Groups para inst√¢ncias EC2, e a natureza escal√°vel dos servi√ßos AWS IoT Core, Lambda e RDS.
* **Edge Computing (Fase Futura):** Pr√©-processamento mais avan√ßado e infer√™ncia de modelos mais simples diretamente nos dispositivos ESP32 (ou gateways de borda mais potentes) para resposta local r√°pida e redu√ß√£o de tr√°fego de dados para a nuvem.
* **Aprendizado Cont√≠nuo (MLOps):** Implementa√ß√£o de um pipeline de MLOps para re-treinamento autom√°tico ou semi-autom√°tico dos modelos com base em novos dados coletados e feedback de performance, garantindo que os modelos se mantenham atualizados.
* **Integra√ß√£o com ERP/Sistemas de Manuten√ß√£o (CMMS):** Desenvolvimento de APIs RESTful para que os alertas e diagn√≥sticos do IndusAI Innovations possam acionar automaticamente ordens de servi√ßo ou requisi√ß√µes de pe√ßas em sistemas de gest√£o empresarial ou de manuten√ß√£o.

---

## üîÑ Pipeline T√©cnico

[Sensores (Vibra√ß√£o, Temperatura, Ru√≠do)] ‚Üí [ESP32: Coleta e Transmiss√£o MQTT] ‚Üí [AWS IoT Core: Roteamento] ‚Üí [AWS Lambda: Pr√©-processamento, Normaliza√ß√£o, Janelamento, Extra√ß√£o de Features] ‚Üí [AWS RDS MySQL: Armazenamento de Dados Processados e Features / AWS S3: Arquivamento de Dados Brutos] ‚Üí [AWS EC2: Treinamento de Modelos ML (Scikit-learn, TensorFlow) e Infer√™ncia Batch/Streaming] ‚Üí [Streamlit Dashboard: Visualiza√ß√£o, M√©tricas, Status Preditivo / Telegram Bot & Email: Alertas Inteligentes]


---

## ‚öôÔ∏è Tecnologias Utilizadas

| Camada                      | Ferramenta / Servi√ßo                                      |
| --------------------------- | --------------------------------------------------------- |
| Programa√ß√£o                 | Python 3.x                                                |
| ML/IA                       | Scikit-learn, TensorFlow (Keras), Pandas, NumPy, Matplotlib |
| IoT                         | ESP32, Sensores Anal√≥gicos/Digitais (Aceler√¥metros, Termistores, Microfones) |
| Transmiss√£o                 | MQTT (JSON payload)                                       |
| Cloud - IoT                 | AWS IoT Core, AWS IoT Device Management                   |
| Cloud - Processamento/L√≥gica | AWS Lambda, AWS EC2 (com Auto Scaling)                    |
| Cloud - Armazenamento       | AWS RDS (MySQL), AWS S3                                   |
| Cloud - Monitoramento/Log    | AWS CloudWatch, AWS CloudTrail                            |
| Cloud - Seguran√ßa           | AWS IAM, AWS KMS, AWS Certificate Manager                 |
| Visualiza√ß√£o                | Streamlit                                                 |
| Comunica√ß√£o/Alertas         | Telegram Bot API, SMTP (Python `smtplib`)                 |
| MLOps (Potencial Futuro)    | MLflow, AWS SageMaker Pipelines                           |

---

## üß™ Estrat√©gia de Coleta de Dados

**Fase 1: Simula√ß√£o e Dados Sint√©ticos**
* Gera√ß√£o de dados sint√©ticos (ex: usando fun√ß√µes senoidais com adi√ß√£o de ru√≠do gaussiano, anomalias simuladas como picos, mudan√ßas de n√≠vel ou frequ√™ncia) para representar tanto opera√ß√£o normal quanto diversos cen√°rios de falha.
* Objetivo: Permitir o desenvolvimento e teste inicial dos modelos de ML e do pipeline de dados antes da disponibilidade de dados reais.

**Fase 2: Coleta Real e Valida√ß√£o Inicial**
* Implementa√ß√£o dos sensores ESP32 em um ambiente de teste ou em equipamentos n√£o cr√≠ticos.
* Coleta cont√≠nua de dados reais via MQTT.
* Rotulagem inicial dos dados com base na observa√ß√£o e em eventos conhecidos.
* Valida√ß√£o e ajuste fino dos modelos de ML com os dados reais.

---

## üóÇ Estrutura do Reposit√≥rio

```
üì¶ indusaiinnovations/
‚î£ üìÇ data/
‚îÉ ‚î£ üìÇ raw/                     ‚Üí Dados brutos (se armazenados localmente antes do S3)
‚îÉ ‚î£ üìÇ processed/               ‚Üí Dados limpos e pr√©-processados (CSV, Parquet)
‚îÉ ‚îó üìÇ synthetic/               ‚Üí Dados sint√©ticos gerados
‚î£ üìÇ iot_firmware/
‚îÉ ‚îó üìÇ esp32/                   ‚Üí C√≥digos do firmware para ESP32 (PlatformIO/Arduino)
‚î£ üìÇ ml_models/
‚îÉ ‚î£ üìÇ notebooks/               ‚Üí Jupyter Notebooks para explora√ß√£o e treinamento
‚îÉ ‚î£ üìÇ scripts/                 ‚Üí Scripts Python para treinamento e infer√™ncia
‚îÉ ‚îó üìÇ saved_models/            ‚Üí Modelos treinados e serializados (Pickle, H5)
‚î£ üìÇ dashboard_app/
‚îÉ ‚îó üìú app.py                   ‚Üí C√≥digo da aplica√ß√£o Streamlit
‚î£ üìÇ lambda_functions/
‚îÉ ‚îó üìÇ preprocessing/           ‚Üí C√≥digo para a fun√ß√£o Lambda de pr√©-processamento
‚î£ üìÇ docs/
‚îÉ ‚î£ üìú architecture.drawio     ‚Üí Diagrama da arquitetura (app.diagrams.net)
‚îÉ ‚îó üìú technical_documentation.md ‚Üí Detalhamento adicional
‚î£ üìú README.md                 ‚Üí Documenta√ß√£o principal do projeto
‚î£ üìú requirements.txt          ‚Üí Depend√™ncias Python do projeto principal (ML, Dashboard)
‚î£ üìú docker-compose.yml        ‚Üí (Opcional) Para ambiente de desenvolvimento local
‚îó üìú main.py                   ‚Üí (Opcional) Script principal para orquestra√ß√£o ou testes locais
```

---

## **üîÑ Fase 2: Simula√ß√£o de Coleta de Dados com ESP32**

Nesta se√ß√£o, detalhamos a implementa√ß√£o da Fase 2 do nosso projeto, focando na simula√ß√£o do subsistema de coleta de dados com ESP32 e sensores virtuais. Esta etapa √© crucial para validar o conceito de aquisi√ß√£o e processamento inicial de dados para a plataforma IndusAI Innovations.

### **2.1 Contexto e Objetivos da Entrega Atual**

A Fase 2 visa aplicar os conhecimentos sobre sistemas embarcados para projetar e simular um sistema b√°sico de coleta de dados. Utilizamos plataformas online como Wokwi para criar um circuito virtual com ESP32 e sensores simulados, reproduzindo o comportamento de sensores f√≠sicos em um ambiente industrial. O foco √© compreender o fluxo de coleta, leitura e an√°lise inicial de dados.

* **Objetivos Espec√≠ficos Desta Entrega:**
    * Criar um circuito virtual funcional com ESP32 e ao menos um sensor simulado no Wokwi.
    * Programar a leitura do sensor no ESP32, ajustando valores simulados para cen√°rios desejados.
    * Registrar os dados lidos (via Monitor Serial, exporta√ß√£o para CSV ou simula√ß√£o textual).
    * Gerar um gr√°fico simples e estat√≠sticas explorat√≥rias com base nos dados coletados ou simulados.
    * Documentar todo o processo detalhadamente no GitHub, incluindo prints, c√≥digo e an√°lises.

### **2.2 Sensores Virtuais Utilizados e Justificativa da Escolha**

Para esta simula√ß√£o inicial, optamos por focar em um sensor de temperatura, que √© vital para a detec√ß√£o de anomalias como o superaquecimento, um dos problemas chave identificados no nosso Business Case.

* **Sensor Selecionado:** **Sensor de Temperatura NTC (Wokwi NTC Temperature Sensor - KY-013)**
* **Justificativa:**
    * **Relev√¢ncia Industrial:** Sensores de temperatura s√£o componentes essenciais em ambientes industriais para monitorar o status t√©rmico de motores, m√°quinas e processos, prevenindo superaquecimentos e falhas catastr√≥ficas. A capacidade de prever picos anormais de temperatura √© diretamente alinhada ao objetivo da IndusAI Innovations de prevenir falhas em linhas cr√≠ticas.
    * **Simplicidade e Representatividade na Simula√ß√£o:** O Wokwi NTC Temperature Sensor √© de f√°cil integra√ß√£o no ambiente virtual, permitindo simular a varia√ß√£o de temperatura de forma controlada atrav√©s de um slider. Isso possibilita a gera√ß√£o de dados que emulam cen√°rios de opera√ß√£o normal e de pr√©-falha (picos de temperatura), fornecendo uma base realista para a an√°lise inicial de dados.
    * **Base para Expans√£o Futura:** Ao dominar a coleta e an√°lise de dados de temperatura, estabelecemos uma base s√≥lida para a integra√ß√£o futura de sensores mais complexos como vibra√ß√£o e ru√≠do, conforme planejado na "L√≥gica e Arquitetura da Solu√ß√£o" do projeto.

### **2.3 Esquema B√°sico do Circuito El√©trico (Simula√ß√£o no Wokwi)**

O circuito foi montado no Wokwi utilizando uma placa ESP32 padr√£o e o sensor de temperatura NTC. A placa do sensor j√° integra o divisor de tens√£o necess√°rio para a leitura do termistor, simplificando as conex√µes.

* **Captura de Tela do Circuito no Wokwi:**
    ![Circuito ESP32 com Sensor NTC no Wokwi](docs/circuit_wokwi.png)

* **Conex√µes Realizadas:**
    * **Pino VCC (positivo)** do Sensor NTC $\rightarrow$ **Pino 3V3** (3.3V) do ESP32.
    * **Pino GND (terra)** do Sensor NTC $\rightarrow$ **Pino GND** do ESP32.
    * **Pino OUT (sinal anal√≥gico)** do Sensor NTC $\rightarrow$ **Pino GPIO 34** do ESP32 (utilizado para leitura anal√≥gica ADC1_CH6).

### **2.4 Leitura dos Dados na Simula√ß√£o (C√≥digo e Funcionamento)**

O firmware do ESP32 foi desenvolvido na linguagem C++ (framework Arduino) e carregado no ambiente de simula√ß√£o do Wokwi. Ele realiza a leitura cont√≠nua do sensor e exibe os dados no Monitor Serial.

* **Trecho Representativo do C√≥digo (`iot_firmware/esp32/main.ino`):**

    ```cpp
    // Defini√ß√µes para o ESP32 e o Termistor NTC
    // THERMISTOR_PIN: Define o pino GPIO 34 do ESP32 para a leitura anal√≥gica do sensor de temperatura.
    //                 GPIO 34 √© um dos pinos ADC (Conversor Anal√≥gico-Digital) do ESP32, adequado para sensores anal√≥gicos.
    const int THERMISTOR_PIN = 34; 

    // NOMINAL_RESISTANCE: Resist√™ncia do termistor em sua temperatura nominal (25¬∞C), tipicamente 10kŒ©.
    const int NOMINAL_RESISTANCE = 10000; 

    // NOMINAL_TEMPERATURE: Temperatura de refer√™ncia para a resist√™ncia nominal, em graus Celsius.
    const int NOMINAL_TEMPERATURE = 25; 

    // B_COEFFICIENT: Coeficiente Beta (B) do termistor. Este valor, junto com a resist√™ncia nominal,
    //                √© usado na equa√ß√£o de Steinhart-Hart para converter resist√™ncia em temperatura.
    //                Um valor t√≠pico para termistores NTC de 10kŒ© √© 3950.
    const int B_COEFFICIENT = 3950; 

    // SERIES_RESISTANCE: Resist√™ncia em s√©rie com o termistor no circuito divisor de tens√£o.
    //                    Como estamos usando uma placa de sensor (KY-013) que j√° integra essa resist√™ncia,
    //                    este valor reflete a resist√™ncia interna da placa para os c√°lculos.
    const int SERIES_RESISTANCE = 10000; 

    // Fun√ß√£o setup(): Executada uma √∫nica vez quando o ESP32 √© iniciado ou reiniciado.
    void setup() {
      // Serial.begin(baudRate): Inicializa a comunica√ß√£o serial entre o ESP32 e o Serial Monitor.
      //                        115200 bps (bits por segundo) √© uma velocidade comum e r√°pida para debug.
      Serial.begin(115200); 

      // analogReadResolution(bits): Define a resolu√ß√£o do ADC. O ESP32 pode usar at√© 12 bits,
      //                             o que significa leituras de 0 a 4095 (2^12 - 1).
      //                             Uma resolu√ß√£o maior oferece maior precis√£o nas leituras anal√≥gicas.
      analogReadResolution(12); 
    }

    // Fun√ß√£o loop(): Executada repetidamente ap√≥s a fun√ß√£o setup().
    void loop() {
      // Leitura do valor anal√≥gico: L√™ o valor bruto do ADC do pino especificado.
      // O valor retornado estar√° entre 0 e 4095, proporcional √† tens√£o no pino.
      int adcValue = analogRead(THERMISTOR_PIN);

      // C√°lculo da resist√™ncia do termistor:
      // Esta f√≥rmula deriva da an√°lise do divisor de tens√£o e √© usada para obter
      // a resist√™ncia atual do termistor com base na leitura do ADC e na resist√™ncia em s√©rie.
      float resistance = SERIES_RESISTANCE / ((4095.0 / adcValue) - 1);

      // C√°lculo da temperatura em Celsius usando a equa√ß√£o de Steinhart-Hart (simplificada):
      // Esta equa√ß√£o √© um modelo matem√°tico amplamente utilizado para converter a resist√™ncia
      // de um termistor NTC para temperatura.
      float steinhart;
      steinhart = resistance / NOMINAL_RESISTANCE;     // Passo 1: R/R0 (resist√™ncia atual sobre resist√™ncia nominal)
      steinhart = log(steinhart);                      // Passo 2: ln(R/R0) (logaritmo natural)
      steinhart /= B_COEFFICIENT;                      // Passo 3: Dividido pelo coeficiente Beta
      steinhart += 1.0 / (NOMINAL_TEMPERATURE + 273.15); // Passo 4: Adiciona 1/T0 (T0 em Kelvin)
      steinhart = 1.0 / steinhart;                     // Passo 5: Inverte para obter a temperatura em Kelvin
      float temperatureC = steinhart - 273.15;         // Passo 6: Converte de Kelvin para Celsius (subtrai 273.15)

      // Impress√£o dos valores no Monitor Serial:
      // Envia os valores lidos e calculados para o Serial Monitor do Wokwi.
      // O "\t" insere um caractere de tabula√ß√£o para organizar a sa√≠da em colunas.
      Serial.print("Valor ADC: ");
      Serial.print(adcValue);
      Serial.print("\tResistencia Calculada: ");
      Serial.print(resistance);
      Serial.print(" ohms\tTemperatura Calculada: ");
      Serial.print(temperatureC);
      Serial.println(" ¬∞C"); // Serial.println adiciona uma quebra de linha

      // delay(milissegundos): Pausa a execu√ß√£o do loop por um tempo especificado.
      // Usamos 1000 ms (1 segundo) para simular uma amostragem de dados a cada segundo (1 Hz).
      delay(1000); 
    }
    ```

* **Breve Explica√ß√£o:**
    * A fun√ß√£o `setup()` inicializa a comunica√ß√£o serial e configura a resolu√ß√£o do ADC para 12 bits, otimizando a precis√£o da leitura.
    * A fun√ß√£o `loop()` executa repetidamente a leitura do valor bruto do ADC do pino GPIO 34. Este valor √©, ent√£o, convertido em resist√™ncia e, subsequentemente, em temperatura em graus Celsius utilizando a equa√ß√£o de Steinhart-Hart. Esta abordagem matem√°tica √© fundamental para a convers√£o precisa de termistores e demonstra o rigor t√©cnico na aquisi√ß√£o de dados.
    * Os valores brutos do ADC, a resist√™ncia calculada e a temperatura em Celsius s√£o impressos no Monitor Serial a cada segundo, permitindo a observa√ß√£o em tempo real e a coleta de dados para an√°lise explorat√≥ria.

* **Registro do Funcionamento da Simula√ß√£o (Monitor Serial):**
    As capturas de tela abaixo demonstram o comportamento do Monitor Serial no Wokwi durante a simula√ß√£o, mostrando as leituras do sensor em diferentes condi√ß√µes. A varia√ß√£o da temperatura foi controlada interativamente atrav√©s do slider do componente NTC no ambiente de simula√ß√£o.

    * **Monitor Serial - Leitura em Condi√ß√£o Normal:**
        ![Monitor Serial - Leitura Normal](docs/serial_monitor_normal.png)
        * *Observa√ß√£o:* Esta captura mostra leituras de temperatura dentro de uma faixa operacional esperada (ex: 20-30¬∞C), simulando um funcionamento est√°vel e sem anomalias do equipamento.

    * **Monitor Serial - Leitura em Condi√ß√£o de Pico (Simulando Anomalia):**
        ![Monitor Serial - Leitura em Pico](docs/serial_monitor_peak.png)
        * *Observa√ß√£o:* Esta captura demonstra um aumento significativo e at√≠pico na temperatura (ex: acima de 35¬∞C), simulando uma condi√ß√£o de superaquecimento que exigiria aten√ß√£o imediata em um cen√°rio industrial real, alinhado aos desafios de manuten√ß√£o preditiva da IndusAI Innovations para evitar paradas inesperadas.

### **2.5 An√°lise Explorat√≥ria Inicial dos Dados Simulados**

Os dados coletados do Monitor Serial foram exportados para um arquivo CSV (`data/processed/dados_temperatura_simulacao.csv`) e processados utilizando um script Python (`data_analysis/analise_temperatura.py`) com as bibliotecas `pandas` e `matplotlib`. Esta an√°lise explorat√≥ria visa extrair insights preliminares do comportamento simulado do sensor, preparando o terreno para a modelagem de Machine Learning em fases futuras.

* **Trecho do C√≥digo Python para An√°lise (`data_analysis/analise_temperatura.py`):**

    ```python
    import pandas as pd
    import matplotlib.pyplot as plt
    import os
    import io

    # Define o caminho para o arquivo CSV de dados.
    # Certifique-se que este caminho est√° correto em rela√ß√£o onde voc√™ vai rodar o script.
    csv_file_path = '../data/processed/dados_temperatura_simulacao.csv'

    # Carrega os dados do arquivo CSV
    if not os.path.exists(csv_file_path):
        print(f"ERRO: Arquivo CSV n√£o encontrado em {csv_file_path}")
        print("Por favor, verifique se voc√™ salvou 'dados_temperatura_simulacao.csv' corretamente na pasta 'data/processed/'.")
        # Caso o CSV n√£o seja encontrado, este bloco de c√≥digo permite que o script continue
        # usando dados de exemplo para que os gr√°ficos e estat√≠sticas sejam gerados.
        # Para a entrega final, o arquivo REAL deve ser gerado no Passo 4 e carregado.
        dados_simulados_str_fallback = """
        Valor ADC,Resistencia Calculada,Temperatura Calculada
        2047,10000.00,25.00
        1950,11025.64,22.45
        2200,8846.15,28.12
        2500,7000.00,32.50
        1800,12500.00,19.80
        1700,13500.00,17.50
        2600,6500.00,34.00
        2700,6000.00,35.50
        2100,9500.00,26.50
        2000,10500.00,23.80
        1600,14500.00,15.00
        2800,5500.00,37.00
        2900,5000.00,38.50
        2300,8000.00,30.00
        2400,7500.00,31.20
        """
        df = pd.read_csv(io.StringIO(dados_simulados_str_fallback))
        print("Continuando com dados de fallback. Por favor, corrija o caminho do CSV para a entrega final.")
    else:
        df = pd.read_csv(csv_file_path)
        print(f"Dados litos com sucesso de: {csv_file_path}")

    df['Tempo (s)'] = df.index 


    output_plot_dir = 'plots'
    if not os.path.exists(output_plot_dir):
        os.makedirs(output_plot_dir)
        print(f"Pasta '{output_plot_dir}' criada para salvar os gr√°ficos.")

    plt.figure(figsize=(12, 6))
    plt.plot(df['Tempo (s)'], df['Temperatura Calculada'], marker='o', linestyle='-', markersize=4)
    plt.title('Simula√ß√£o de Leitura de Temperatura ao Longo do Tempo', fontsize=16)
    plt.xlabel('Tempo (segundos)', fontsize=12)
    plt.ylabel('Temperatura (¬∞C)', fontsize=12)
    plt.grid(True, linestyle='--', alpha=0.7)
    plt.tight_layout()
    plt.savefig(os.path.join(output_plot_dir, 'temperatura_linha.png')) # 
    plt.show()


    plt.figure(figsize=(10, 6))
    plt.hist(df['Temperatura Calculada'], bins=7, edgecolor='black', alpha=0.8)
    plt.title('Distribui√ß√£o das Temperaturas Calculadas Simuladas', fontsize=16)
    plt.xlabel('Temperatura (¬∞C)', fontsize=12)
    plt.ylabel('Frequ√™ncia', fontsize=12)
    plt.grid(axis='y', linestyle='--', alpha=0.7)
    plt.tight_layout()
    plt.savefig(os.path.join(output_plot_dir, 'temperatura_histograma.png'))
    plt.show()

    print("\n--- Estat√≠sticas Descritivas da Temperatura Calculada ---")
    desc_stats = df['Temperatura Calculada'].describe()
    print(desc_stats)

    print("\n--- Cinco Primeiras Leituras ---")
    print(df.head())

    print("\n--- Cinco √öltimas Leituras ---")
    print(df.tail())


    print("\n--- Insights Iniciais dos Dados Simulados ---")
    min_temp = df['Temperatura Calculada'].min()
    max_temp = df['Temperatura Calculada'].max()
    mean_temp = df['Temperatura Calculada'].mean()
    print(f"A temperatura simulada variou de {min_temp:.2f}¬∞C a {max_temp:.2f}¬∞C.")
    print(f"A m√©dia das temperaturas registradas foi de {mean_temp:.2f}¬∞C.")
    print("O gr√°fico de linha mostra a flutua√ß√£o da temperatura ao longo do tempo, simulando varia√ß√µes em um ambiente industrial.")
    print("Os picos de temperatura observados, como em leituras acima de 30¬∞C, poderiam indicar em um cen√°rio real")
    print("um poss√≠vel superaquecimento de equipamentos, o que √© um foco para a detec√ß√£o preditiva de falhas da IndusAI Innovations.")
    print("A distribui√ß√£o (histograma) indica as faixas de temperatura mais frequentes durante a simula√ß√£o.")
    ```

* **Gr√°ficos Gerados:**

    * **Gr√°fico de Linha da Temperatura ao Longo do Tempo:**
        ![Gr√°fico de Linha da Temperatura Simulada](data_analysis/plots/temperatura_linha.png)
        * *An√°lise:* Este gr√°fico ilustra a s√©rie temporal das leituras de temperatura. √â poss√≠vel observar as flutua√ß√µes e os picos de temperatura simulados, que em um ambiente industrial real, seriam indicativos de varia√ß√µes de carga ou potenciais anomalias no equipamento. A capacidade de visualizar esses padr√µes √© o primeiro passo para a detec√ß√£o preditiva de falhas.

    * **Histograma da Distribui√ß√£o das Temperaturas Simuladas:**
        ![Histograma da Temperatura Simulada](data_analysis/plots/temperatura_histograma.png)
        * *An√°lise:* O histograma demonstra a distribui√ß√£o das temperaturas registradas durante a simula√ß√£o. Ele permite identificar as faixas de temperatura mais frequentes e a ocorr√™ncia de valores at√≠picos (outliers), que podem corresponder aos picos de superaquecimento simulados.

* **Estat√≠sticas Descritivas da Temperatura Calculada:**

    ```
    count    214.000000
    mean     35.371028
    std       29.716752
    min      -19.110000
    25%        9.390000
    50%       37.000000
    75%       61.337500
    max       79.970000
    Name: Temperatura Calculada, dtype: float64
    ```

* **Insights Iniciais dos Dados Simulados:**
    * A temperatura simulada variou de **-19.11¬∞C** a **79.97¬∞C**, com uma m√©dia de **35.37¬∞C**. Essa varia√ß√£o controlada permitiu simular diferentes estados operacionais de um equipamento.
    * O gr√°fico de linha demonstra claramente as flutua√ß√µes e picos de temperatura. Em um contexto real, esses picos seriam cruciais para a identifica√ß√£o de sobrecargas ou defici√™ncias no sistema de resfriamento.
    * A distribui√ß√£o (histograma) mostra que a maioria das leituras se concentra em uma faixa, mas a presen√ßa de valores mais elevados indica a capacidade de simular e detectar cen√°rios de risco, fundamental para a manuten√ß√£o preditiva proposta pela IndusAI Innovations.
    * Esta fase de simula√ß√£o provou a viabilidade da coleta e an√°lise b√°sica de dados de um sensor com ESP32, um passo fundamental para o desenvolvimento do pipeline de dados completo e os modelos de Machine Learning.

### **2.6 Estrutura do Reposit√≥rio (Atualizada para a Fase 2)**

Para refletir os novos entreg√°veis desta fase, a estrutura do reposit√≥rio foi expandida para incluir os dados processados, o c√≥digo Python de an√°lise e os gr√°ficos gerados, al√©m dos arquivos da simula√ß√£o no Wokwi.

```bash
üìÅ indusaiinnovations/
‚îú‚îÄ‚îÄ üìÅ assets/                            # Recursos est√°ticos (ex: logo FIAP)
‚îú‚îÄ‚îÄ üìÅ data/
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ raw/
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ processed/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ dados_temperatura_simulacao.csv  # Dados coletados do monitor serial
‚îÇ   ‚îî‚îÄ‚îÄ üìÅ synthetic/
‚îú‚îÄ‚îÄ üìÅ iot_firmware/
‚îÇ   ‚îî‚îÄ‚îÄ üìÅ esp32/
‚îÇ       ‚îî‚îÄ‚îÄ üìÑ main.ino                     # C√≥digo Arduino para o ESP32 (simula√ß√£o Wokwi)
‚îÇ
‚îú‚îÄ‚îÄ üìÅ ml_models/
‚îú‚îÄ‚îÄ üìÅ notebooks/
‚îú‚îÄ‚îÄ üìÅ scripts/
‚îú‚îÄ‚îÄ üìÅ saved_models/
‚îú‚îÄ‚îÄ üìÅ dashboard_app/
‚îÇ   ‚îî‚îÄ‚îÄ üìÑ app.py
‚îú‚îÄ‚îÄ üìÅ lambda_functions/
‚îú‚îÄ‚îÄ üìÅ preprocessing/
‚îÇ
‚îú‚îÄ‚îÄ üìÅ data_analysis/                      # NOVA PASTA PARA AN√ÅLISE DE DADOS DA FASE 2
‚îÇ   ‚îî‚îÄ‚îÄ üìÑ analise_temperatura.py          # Script Python para an√°lise e gr√°ficos
‚îÇ
‚îú‚îÄ‚îÄ üìÅ plots/
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ temperatura_linha.png           # Imagem do gr√°fico de linha da temperatura
‚îÇ   ‚îî‚îÄ‚îÄ üìÑ temperatura_histograma.png      # Imagem do histograma da temperatura
‚îÇ
‚îú‚îÄ‚îÄ üìÅ docs/
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ architecture.drawio
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ technical_documentation.md
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ circuit_wokwi.png               # Imagem do seu circuito no Wokwi
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ serial_monitor_normal.png       # Print do Monitor Serial (normal)
‚îÇ   ‚îî‚îÄ‚îÄ üìÑ serial_monitor_peak.png         # Print do Monitor Serial (pico)
‚îÇ
‚îú‚îÄ‚îÄ üìÑ README.md                           # Documenta√ß√£o principal do projeto
‚îú‚îÄ‚îÄ üìÑ requirements.txt
‚îú‚îÄ‚îÄ üìÑ docker-compose.yml
‚îî‚îÄ‚îÄ üìÑ main.py
```

## üìÖ Roadmap de Desenvolvimento (Atualizado)

| Etapa | Descri√ß√£o |
| -------- | --------------------------------------------------------------------------------------------------------------------------------------- |
| **Fase 1 (Conclu√≠da)** | Defini√ß√£o detalhada da arquitetura, planejamento do pipeline de dados, simula√ß√£o de coleta e gera√ß√£o de dados sint√©ticos, estrutura inicial do reposit√≥rio. |
| **Fase 2 (Atual - Curso)** | **Desenvolvimento e simula√ß√£o de um circuito ESP32 com sensor de temperatura no Wokwi, coleta e an√°lise explorat√≥ria inicial dos dados gerados, e documenta√ß√£o detalhada dos passos e resultados.** |

---

## üìö Refer√™ncias

* Hermes Reply: [https://www.reply.com/hermes-reply/pt](https://www.reply.com/hermes-reply/pt)
* AWS IoT Core: [https://aws.amazon.com/iot-core/](https://aws.amazon.com/iot-core/)
* AWS Lambda: [https://aws.amazon.com/lambda/](https://aws.amazon.com/lambda/)
* AWS RDS: [https://aws.amazon.com/rds/](https://aws.amazon.com/rds/)
* AWS EC2: [https://aws.amazon.com/ec2/](https://aws.amazon.com/ec2/)
* Streamlit: [https://streamlit.io/](https://streamlit.io/)
* MQTT Protocol: [https://mqtt.org/](https://mqtt.org/)
* Scikit-learn: [https://scikit-learn.org/](https://scikit-learn.org/)
* TensorFlow: [https://www.tensorflow.org/](https://www.tensorflow.org/)
* **Wokwi Simulator:** [https://wokwi.com/](https://wokwi.com/)
